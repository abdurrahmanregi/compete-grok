# CompeteGrok Analysis Report

**Query:** explain BLP demand estimation step by step

**Timestamp:** 2025-12-17 15:37:33.728195

**Routes:** []

### Agent Output
### BLP Demand Estimation: Step-by-Step Explanation

The Berry-Levinsohn-Pakes (BLP) model (from Berry, Levinsohn, and Pakes, *Econometrica* 1995) is a cornerstone of empirical industrial organization (IO) economics. It estimates **demand for differentiated products** in markets with thousands of consumers, accounting for:

- **Price endogeneity** (prices correlate with unobserved quality shocks Î¾).
- **Heterogeneity** in consumer preferences (via random coefficients).
- **Market equilibrium** (supply side often estimated jointly, but focus here is demand).

It extends the **Berry (1994) inversion** from the homogeneous logit and uses **nonlinear Generalized Method of Moments (GMM)** for estimation. The core challenge: demand is nonlinear in parameters, so we **invert** observed market shares to recover mean utilities Î´, then use GMM to fit the model.

I'll explain **demand estimation only** (supply can be added post-demand). Assume:
- **Markets** t = 1 to T (e.g., city-quarters).
- **Products** j = 1 to J_t in each market.
- Data: prices p_{jt}, characteristics x_{jt} (e.g., size, HP), **observed market shares** s_{jt} (e.g., from aggregate sales / total potential sales).
- **Outside good** share s_{0t} = 1 - âˆ‘_j s_{jt}.

#### **Step 1: Specify the Random Coefficients Logit Utility**
Consumer *i*'s utility for product *j* in market *t*:
```
u_{ijt} = Î´_{jt} + Î¼_{ijt}(p_{jt}, x_{jt}, Î½_i; Î¸_Î£) + Îµ_{ijt}
```
- **Mean utility** Î´_{jt} = x_{jt} Î²_x + Î± p_{jt} + Î¾_{jt}
  - x_{jt}: Observed product chars (e.g., size, dummy for air conditioning).
  - p_{jt}: Price.
  - Î²_x, Î±: Mean tastes (Î± < 0 for downward-sloping demand).
  - Î¾_{jt}: Unobserved (mean-zero) product quality shock â†’ **endogenous**.
- **Heterogeneity** Î¼_{ijt} = âˆ‘_k Ïƒ_k Î½_{ik} x_{jkt}  (often includes price: Ïƒ_p Î½_{ip} p_{jt}).
  - Î½_i ~ G(Î½) (e.g., i.i.d. standard normal; simulated with H=100-500 draws).
  - Î¸_Î£ = {Ïƒ_k}: Nonlinear **random coefficient** parameters â†’ allow flexible substitution patterns.
- Îµ_{ijt} ~ Type I extreme value (Gumbel) â†’ induces logit form conditionally on Î½_i.

**Structural parameters** Î¸ = (Î¸_1, Î¸_2) = (Î²_x, Î±; Î¸_Î£).

#### **Step 2: Derive Predicted Market Shares**
Integrate over consumer heterogeneity:
```
Å_{jt}(Î´_t, p_t, x_t; Î¸_2) = âˆ« [exp(Î´_{jt} + Î¼_{ijt}) / (1 + âˆ‘_k exp(Î´_{kt} + Î¼_{ikt})) ] dG(Î½_i)
```
- Denominator = 1 (outside good) + âˆ‘ inside goods.
- **Simulate** the integral: Draw H vectors Î½^{(h)}, average over h=1 to H.
- Observed s_{jt} **must equal** Å_{jt} for the true Î´_t and Î¸_2 â†’ **implicit equation**.

#### **Step 3: Invert Shares to Recover Mean Utilities Î´_t(Î¸_2) (Contraction Mapping)**
For fixed Î¸_2, solve **nonlinear system** for Î´_t (J_t equations per market t):
```
s_{jt} = Å_{jt}(Î´_t, p_t, x_t; Î¸_2)   âˆ€ j,t
```
Equivalent to (taking log-odds vs. outside good):
```
log(s_{jt} / s_{0t}) = log( Å_{jt}(Î´_t) / (1 - âˆ‘_k Å_{kt}(Î´_t)) )
```
- **BLP contraction mapping** (guaranteed to converge; Picard fixed-point theorem):
  1. Initialize: Î´^{(0)}_{jt} = log(s_{jt} / s_{0t}).
  2. Iterate r=1,2,... until ||Î´^{(r)} - Î´^{(r-1)}|| < Îµ (e.g., 10^{-12}; ~20 iterations):
     ```
     Î´^{(r)}_{jt} = log(s_{jt} / s_{0t}) - log( E_Î½ [ exp(Î´^{(r-1)}_{jt} + Î¼_{jt}(Î½)) / D_t(Î´^{(r-1)}, Î½) ] )
     ```
     - D_t(Î´, Î½) = 1 + âˆ‘_k exp(Î´_{kt} + Î¼_{kt}(Î½))  (choice-specific denom).
     - E_Î½[Â·] = (1/H) âˆ‘_h [Â·] over simulation draws.
  3. Output: Î´_t(Î¸_2) â†’ "unobserved" mean utilities backed out from data.

This is **fast** per candidate Î¸_2 (vectorized in code like MATLAB/Python).

#### **Step 4: Form Residuals and Moment Conditions**
```
Î¾_{jt}(Î¸) = Î´_{jt}(Î¸_2) - x_{jt} Î²_x - Î± p_{jt}
```
- Orthogonality: E[Î¾_{jt} | Z_{jt}] = 0 (instruments Z_{jt} uncorrelated with Î¾).
- **Instruments Z** (critical for price endogeneity):
  | Type | Examples |
  |------|----------|
  | **Product chars** | Own x_{jt} (for non-price). |
  | **Cost shifters** | Materials/labor costs (if available). |
  | **Hausman-style** | âˆ‘_{kâ‰ j} x_{kt} (rival chars; orthogonal under monopoly pricing). |
  | **BLP** | âˆ‘_{kâˆˆ same nest/group} x_{kt} (e.g., by firm/size). |
- Stack: Let Z_t be (J_t Ã— L) instruments matrix per market.
- Sample moments: Ïˆ(Î¸) = (1/âˆ‘ J_t) âˆ‘_t Z_t' Î¾_t(Î¸).

#### **Step 5: Nonlinear GMM Optimization**
Minimize quadratic form:
```
Q(Î¸) = Ïˆ(Î¸)' W Ïˆ(Î¸)
```
- **W**: Weighting matrix.
  - 1st stage: Identity (or diagonal).
  - 2nd stage: Optimal W = [âˆ‘ Z_t' Î¾ Î¾' Z_t]^{-1} (iterate).
- **Nested optimization** (Î¸_2 high-dimensional, e.g., 5-10 sigmas):
  1. **Outer loop**: Grid/search/optimize Î¸_2 (e.g., Nelder-Mead, or Bayesian).
     - For each Î¸_2 candidate:
       - Run contraction (Step 3) â†’ Î´_t(Î¸_2).
       - **Inner linear GMM**: Solve Î¸_1(Î¸_2) = argmin Ïˆ(Î¸_1,Î¸_2)' W Ïˆ = (Z'X W Z'X)^{-1} etc. (2SLS projection: Î¸_1 = (X' Z W Z' X)^{-1} X' Z W Z' Î´).
       - Compute Q(Î¸_1(Î¸_2), Î¸_2).
  2. Converged Î¸ â†’ estimates.
- Software: Nevo's MATLAB code, pyblp (Python), or R packages.

#### **Step 6: Inference and Diagnostics**
- **Standard errors**: GMM variance-covariance:
  ```
  Var(Î¸) = (1/N) [D' W D]^{-1} (D' W Î© W D) [D' W D]^{-1}
  ```
  - D = âˆ‚Ïˆ/âˆ‚Î¸ (numerical Jacobian).
  - Î© = var(âˆšN Ïˆ) â‰ˆ (1/N) âˆ‘ Z_t Î¾_t Î¾_t' Z_t.
- **Diagnostics**:
  - Overidentification: Hansen J-test (should not reject).
  - Monotonicity: Elasticities â†“ in price.
  - OWBP test (O'Brien-Wansbeek-Pagan): Check inversion.
  - Plots: Î´ vs. fitted; shares fit.

#### **Key Insights & Caveats**
- **Why it works**: Inversion linearizes heterogeneity; GMM handles endogeneity.
- **Computation**: O(T Ã— J^2 Ã— H Ã— outer its) â†’ feasible with J~20, T~50, H=200.
- **Extensions**: Nested logit (group sigmas), full supply (markup eq: p - c = Î¼(s,Î¸)), dynamics.
- **Common pitfalls**: Bad instruments â†’ bias; few sims H â†’ noisy; collinear x.
- **Empirical use**: Autos (BLP original), cereals, airlines, pharma.

For code/examples, see pyblp docs or Nevo (2000) handbook chapter. If you need supply-side, simulations, or caveats for a specific app, ask!

### Agent Output


**Synthesis:** See above.


**Privacy:** Ephemeral RAG; zero retention.  
**Disclaimer:** Not legal advice. Models have caveats (e.g. IIA assumption). Verify 2025 data.  
**LaTeX:** Inline (\`x\), display [`E=mc^2\].[`\]
[`\](\`\)

